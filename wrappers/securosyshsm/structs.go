//Copyright (c) 2025 Securosys SA.

package securosyshsm

import (
	"crypto/x509"
	"encoding/json"
	"encoding/pem"
	"fmt"

	log "github.com/hashicorp/go-hclog"
	"github.com/mitchellh/cli"
	helpers "github.com/openbao/go-kms-wrapping/keystores/securosyshsm/v2/helpers"
)

// Struct storing generated data
type Key struct {
	// Key label from Securosys TSB
	RSALabel      string `mapstructure:"RSALabel"`
	RSAPublicKey  string `mapstructure:"RSAPublicKey"`
	KeyAttributes KeyAttributes
	RSAPassword   string
}

// Struct contains settings options
type Settings struct {
	// Authorization has been on of this consts [NONE,TOKEN,CERT]
	Auth string
	// BearerToken needed is needed only with Auth=TOKEN
	BearerToken string
	// BasicToken needed is needed only with Auth=BASIC or if not exists You Have to prive UserName and Password
	// CertPath needed is needed only with Auth=CERT
	CertPath string
	// KeyPath needed is needed only with Auth=CERT
	KeyPath string
	// Rest Api url where is located Securosys HSM
	RestApi string
	// Integer as Number in seconds for checking approval interval
	CheckEvery int
	// ApprovalTimeout must be bigger then CheckEvery and lower then VAULT_CLIENT_TIMEOUT. Default: 60s
	ApprovalTimeout int
	// Enables/Disables debug on Securosys Requests. If not exists in config, then debug logs will be only awaylable in Tests
	Debug                  *bool
	ApiKeys                ApiKeyTypes
	ApplicationKeyPair     KeyPair
	CurrentApiKeyTypeIndex ApiKeyTypesRetry
}

// Main struct of securosys_hsm YML
type Configurations struct {
	// Struct With Application Settings
	Settings Settings `mapstructure:"Settings"`
	// List of Name - Public Key needed for Securosys HSM with policy
	Policy *helpers.Policy `mapstructure:"Policy"`
	// Autogenerated data from application. Do not change this manually!
	Key Key `mapstructure:"Generated"`
}

type Logging struct {
	UI     cli.Ui
	Logger log.Logger
}

// STRUCTS

type approval struct {
	TypeOfKey string  `json:"type"`
	Name      *string `json:"name"`
	Value     *string `json:"value"`
}
type group struct {
	Name      string     `json:"name"`
	Quorum    int        `json:"quorum"`
	Approvals []approval `json:"approvals"`
}
type token struct {
	Name     string  `json:"name"`
	Timelock int     `json:"timelock"`
	Timeout  int     `json:"timeout"`
	Groups   []group `json:"groups"`
}
type rule struct {
	Tokens []token `json:"tokens"`
}
type keyStatus struct {
	Blocked bool `json:"blocked"`
}

// Policy structure for rules use, block, unblock, modify
type Policy struct {
	RuleUse     rule       `json:"ruleUse"`
	RuleBlock   *rule      `json:"ruleBlock"`
	RuleUnBlock *rule      `json:"ruleUnblock"`
	RuleModify  *rule      `json:"ruleModify"`
	KeyStatus   *keyStatus `json:"keyStatus,omitempty"`
}

// Structure for all asychnronous operations
type RequestResponse struct {
	Id               string   `json:"id"`
	Status           string   `json:"status"`
	ExecutionTime    string   `json:"executionTime"`
	ApprovedBy       []string `json:"approvedBy"`
	NotYetApprovedBy []string `json:"notYetApprovedBy"`
	RejectedBy       []string `json:"rejectedBy"`
	Result           string   `json:"result"`
}

// Structure for get key attributes response
type KeyAttributes struct {
	Label              string
	Attributes         map[string]bool
	KeySize            float64
	Policy             Policy
	PublicKey          string
	Algorithm          string
	AlgorithmOid       string
	CurveOid           string
	Version            string
	Active             bool
	Xml                string
	XmlSignature       string
	AttestationKeyName string
}

type KeyPair struct {
	PrivateKey *string `json:"privateKey,omitempty"`
	PublicKey  *string `json:"publicKey,omitempty"`
}

type ApiKeyTypes struct {
	KeyManagementToken         []string `json:"KeyManagementToken,omitempty"`
	KeyOperationToken          []string `json:"KeyOperationToken,omitempty"`
	ApproverToken              []string `json:"ApproverToken,omitempty"`
	ServiceToken               []string `json:"ServiceToken,omitempty"`
	ApproverKeyManagementToken []string `json:"ApproverKeyManagementToken,omitempty"`
}

func (keyTypes *ApiKeyTypes) ToJSON() string {
	marshal, err := json.Marshal(keyTypes)
	if err != nil {
		return ""
	}
	return string(marshal)
}

type ApiKeyTypesRetry struct {
	KeyManagementTokenIndex         int
	KeyOperationTokenIndex          int
	ApproverTokenIndex              int
	ServiceTokenIndex               int
	ApproverKeyManagementTokenIndex int
}

const (
	KeyManagementTokenName         = "KeyManagementToken"
	KeyOperationTokenName          = "KeyOperationToken"
	ApproverTokenName              = "ApproverToken"
	ServiceTokenName               = "ServiceToken"
	ApproverKeyManagementTokenName = "ApproverKeyManagementToken"
)

// END STRUCTS
func ReadCertificate(possibleCertificate string) (*x509.Certificate, error) {
	block, _ := pem.Decode([]byte(WrapCertificateWithHeaders(possibleCertificate)))
	if block == nil {
		return nil, fmt.Errorf("Cannot parse certificate")
	}
	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return nil, err
	}
	return cert, nil
}
func WrapCertificateWithHeaders(certificate string) []byte {
	return []byte("-----BEGIN CERTIFICATE-----\n" + certificate + "\n-----END CERTIFICATE-----")

}
func WrapPublicKeyWithHeaders(publicKey string) []byte {
	return []byte("-----BEGIN RSA PUBLIC KEY-----\n" + publicKey + "\n-----END RSA PUBLIC KEY-----")

}
